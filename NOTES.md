# Next.js Official Tutorial Progress

### Етап 1: Getting Started

**Що зроблено:**
Ініціалізовано проект, використовуючи стартовий шаблон курсу Next.js Learn. Встановлено необхідні залежності (`npm install`) та запущено локальний сервер розробки командою `pnpm dev
`. Перевірено відображення стартової сторінки за адресою `localhost:3000`.

**Скріншот:**
![Start.png](screenshots/Start.png)
**Мої думки/питання:**
Середовище налаштувалося швидко. Стартовий шаблон вже містить певний UI.
### Етап 2: CSS Styling

**Що зроблено:**
Додано глобальні стилі до застосунку. Я імпортував файл `/app/ui/global.css` у кореневий макет (`/app/layout.tsx`), щоб стилі застосовувалися до всіх сторінок. Також ознайомився з використанням Tailwind CSS для швидкої стилізації компонентів та бібліотекою `clsx` для умовного перемикання класів.

**Скріншот:**
![CSS Styling](screenshots/Styles.png)

**Мої думки/питання:**
Використання Tailwind значно пришвидшує верстку, оскільки не потрібно постійно перемикатися між файлами стилів. Глобальні стилі одразу змінили вигляд всього проєкту.
### Етап 3: Optimizing Fonts and Images

**Що зроблено:**
Налаштовано шрифти та зображення для оптимізації продуктивності:
1. Підключено Google Fonts (`Inter` для основного тексту та `Lusitana` для заголовків) через `next/font/google`. Це запобігає зсуву макета (CLS) під час завантаження шрифтів.
2. Додано логотип `AcmeLogo` та герой-зображення (Hero Images) за допомогою компонента `<Image>`.
3. Налаштовано відображення різних зображень для мобільних та десктопних пристроїв за допомогою CSS-класів (hidden/block).

**Скріншот:**
![Fonts and Images](./screenshots/Fonts_Images.png)

**Мої думки/питання:**
Компонент `<Image>` автоматично обробляє такі складні речі, як "lazy loading" та зміна розміру, що дуже зручно. Також цікаво, що шрифти завантажуються на сервері під час білду, а не клієнтом.
### Етап 4: Creating Layouts and Pages

**Що зроблено:**
Створено маршрутизацію (file-system routing) для панелі керування:
1. Створено сторінки `dashboard/page.tsx`, `dashboard/customers/page.tsx` та `dashboard/invoices/page.tsx`.
2. Створено файл `dashboard/layout.tsx` для спільного макету. Тепер бічна панель `<SideNav />` відображається на всіх сторінках дашборду.
3. Використано проп `children` у компоненті Layout, щоб автоматично підставляти контент поточної сторінки.

**Скріншот:**
![Layouts and Pages](./screenshots/Routes.png)

**Мої думки/питання:**
Головна перевага використання `layout.tsx` — це те, що при переході між сторінками перерендериться тільки контент (children), а бічна панель залишається статичною. Це економить ресурси та покращує UX.
### Етап 5: Navigating Between Pages

**Що зроблено:**
Оптимізовано навігацію в застосунку:
1. Замінено стандартні теги `<a>` на компонент `<Link>` з `next/link`. Це дозволяє переходити між сторінками миттєво без повного перезавантаження сторінки (client-side navigation).
2. Реалізовано патерн "Active Link" (активне посилання). За допомогою хука `usePathname()` я отримую поточний шлях URL і, використовуючи бібліотеку `clsx`, умовно додаю класи стилів, щоб підсвітити активну сторінку в меню.

**Скріншот:**
![Navigation and Active Links](./screenshots/Links.png)

**Мої думки/питання:**
Дуже зручно, що Next.js автоматично розбиває код (code splitting) за маршрутами. Крім того, при наведенні на посилання `<Link>`, Next.js фоново передзавантажує код цільової сторінки, що робить перехід миттєвим.
### Етап 6: Setting Up Your Database

**Що зроблено:**
Налаштовано хмарну базу даних PostgreSQL (через Vercel Postgres):
1. Створено проект на Vercel та підключено базу даних.
2. Налаштовано змінні оточення у файлі `.env` для доступу до БД.
3. Використано скрипт `seed.js` для створення таблиць (users, customers, invoices, revenue) та наповнення їх початковими даними.
4. Перевірено з'єднання з базою, виконавши тестовий SQL-запит, який повернув дані з таблиці `invoices`.

**Скріншот:**
![Database Setup](./screenshots/database.png)

**Мої думки/питання:**
Цікаво, що Next.js дозволяє писати SQL-запити безпосередньо, використовуючи Vercel SDK. Скрипт seeding дуже корисний для розробки, бо дозволяє одразу працювати з наповненим інтерфейсом, а не пустими таблицями.