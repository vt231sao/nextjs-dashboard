# Next.js Official Tutorial Progress

### Етап 1: Getting Started

**Що зроблено:**
Ініціалізовано проект, використовуючи стартовий шаблон курсу Next.js Learn. Встановлено необхідні залежності (`npm install`) та запущено локальний сервер розробки командою `pnpm dev
`. Перевірено відображення стартової сторінки за адресою `localhost:3000`.

**Скріншот:**
![Start.png](screenshots/Start.png)
**Мої думки/питання:**
Середовище налаштувалося швидко. Стартовий шаблон вже містить певний UI.
### Етап 2: CSS Styling

**Що зроблено:**
Додано глобальні стилі до застосунку. Я імпортував файл `/app/ui/global.css` у кореневий макет (`/app/layout.tsx`), щоб стилі застосовувалися до всіх сторінок. Також ознайомився з використанням Tailwind CSS для швидкої стилізації компонентів та бібліотекою `clsx` для умовного перемикання класів.

**Скріншот:**
![CSS Styling](screenshots/Styles.png)

**Мої думки/питання:**
Використання Tailwind значно пришвидшує верстку, оскільки не потрібно постійно перемикатися між файлами стилів. Глобальні стилі одразу змінили вигляд всього проєкту.
### Етап 3: Optimizing Fonts and Images

**Що зроблено:**
Налаштовано шрифти та зображення для оптимізації продуктивності:
1. Підключено Google Fonts (`Inter` для основного тексту та `Lusitana` для заголовків) через `next/font/google`. Це запобігає зсуву макета (CLS) під час завантаження шрифтів.
2. Додано логотип `AcmeLogo` та герой-зображення (Hero Images) за допомогою компонента `<Image>`.
3. Налаштовано відображення різних зображень для мобільних та десктопних пристроїв за допомогою CSS-класів (hidden/block).

**Скріншот:**
![Fonts and Images](./screenshots/Fonts_Images.png)

**Мої думки/питання:**
Компонент `<Image>` автоматично обробляє такі складні речі, як "lazy loading" та зміна розміру, що дуже зручно. Також цікаво, що шрифти завантажуються на сервері під час білду, а не клієнтом.
### Етап 4: Creating Layouts and Pages

**Що зроблено:**
Створено маршрутизацію (file-system routing) для панелі керування:
1. Створено сторінки `dashboard/page.tsx`, `dashboard/customers/page.tsx` та `dashboard/invoices/page.tsx`.
2. Створено файл `dashboard/layout.tsx` для спільного макету. Тепер бічна панель `<SideNav />` відображається на всіх сторінках дашборду.
3. Використано проп `children` у компоненті Layout, щоб автоматично підставляти контент поточної сторінки.

**Скріншот:**
![Layouts and Pages](./screenshots/Routes.png)

**Мої думки/питання:**
Головна перевага використання `layout.tsx` — це те, що при переході між сторінками перерендериться тільки контент (children), а бічна панель залишається статичною. Це економить ресурси та покращує UX.
### Етап 5: Navigating Between Pages

**Що зроблено:**
Оптимізовано навігацію в застосунку:
1. Замінено стандартні теги `<a>` на компонент `<Link>` з `next/link`. Це дозволяє переходити між сторінками миттєво без повного перезавантаження сторінки (client-side navigation).
2. Реалізовано патерн "Active Link" (активне посилання). За допомогою хука `usePathname()` я отримую поточний шлях URL і, використовуючи бібліотеку `clsx`, умовно додаю класи стилів, щоб підсвітити активну сторінку в меню.

**Скріншот:**
![Navigation and Active Links](./screenshots/Links.png)

**Мої думки/питання:**
Дуже зручно, що Next.js автоматично розбиває код (code splitting) за маршрутами. Крім того, при наведенні на посилання `<Link>`, Next.js фоново передзавантажує код цільової сторінки, що робить перехід миттєвим.
### Етап 6: Setting Up Your Database

**Що зроблено:**
Налаштовано хмарну базу даних PostgreSQL (через Vercel Postgres):
1. Створено проект на Vercel та підключено базу даних.
2. Налаштовано змінні оточення у файлі `.env` для доступу до БД.
3. Використано скрипт `seed.js` для створення таблиць (users, customers, invoices, revenue) та наповнення їх початковими даними.
4. Перевірено з'єднання з базою, виконавши тестовий SQL-запит, який повернув дані з таблиці `invoices`.

**Скріншот:**
![Database Setup](./screenshots/database.png)

**Мої думки/питання:**
Цікаво, що Next.js дозволяє писати SQL-запити безпосередньо, використовуючи Vercel SDK. Скрипт seeding дуже корисний для розробки, бо дозволяє одразу працювати з наповненим інтерфейсом, а не пустими таблицями.
### Етап 7: Fetching Data

**Що зроблено:**
Налаштовано отримання реальних даних з бази даних PostgreSQL:
1. Компонент сторінки `Page` перетворено на асинхронний (`async`), що дозволяє використовувати `await` для запитів даних.
2. Використано функції `fetchRevenue`, `fetchLatestInvoices` та `fetchCardData` (з файлу `app/lib/data.ts`), які виконують SQL-запити до бази.
3. Видалено захардкоджені дані, тепер графіки та таблиці відображають актуальну інформацію з БД.
4. Розглянуто проблему "Request Waterfalls" (каскад запитів), коли один запит чекає виконання попереднього.

**Скріншоти:**
![Revenue Chart](./screenshots/Revenue.png)
![Latest Invoices](./screenshots/LatestInvoices.png)
![Dashboard Cards](./screenshots/Cards.png)

**Мої думки/питання:**
Це одна з найкрутіших фіч Next.js App Router — можливість писати SQL-запити прямо в компонентах (Server Components). Це безпечно, бо цей код виконується тільки на сервері і не потрапляє в браузер клієнта.
### Етап 8: Static and Dynamic Rendering

**Що зроблено:**
1. Ознайомився з різницею між статичним (Static) та динамічним (Dynamic) рендерингом.
2. Використовував `unstable_noStore` з `next/cache`, щоб вимкнути кешування даних і змусити сторінку рендеритися динамічно при кожному запиті.
3. Додав штучну затримку (`await new Promise(...)`) на 3 секунди у функцію `fetchRevenue`, щоб симулювати повільну мережу.
4. Переконався, що при динамічному рендерингу повільний запит блокує завантаження всієї сторінки.

**Скріншот:**
![Artificial Delay Log](./screenshots/Delay.png)

**Мої думки/питання:**
Динамічний рендеринг корисний, щоб бачити актуальні дані, але має недолік: якщо один запит до бази "тупить", користувач бачить білий екран. Потрібно знайти спосіб показувати частину сторінки одразу, не чекаючи решти.
### Етап 9: Streaming

**Що зроблено:**
Оптимізовано завантаження сторінки за допомогою Streaming:
1. Створено файл `loading.tsx` у папці `/app/dashboard`. Цей файл автоматично працює як обгортка React Suspense для всієї сторінки, показуючи "скелет" інтерфейсу під час завантаження даних.
2. Реалізовано потокову передачу для окремих компонентів. Я виніс логіку затримки та отримання даних безпосередньо в компоненти `<RevenueChart />` та `<LatestInvoices />`.
3. Обгорнув ці компоненти в `<Suspense>` з власними `fallback`. Тепер статичні частини сторінки завантажуються миттєво, а важкі графіки підвантажуються незалежно, не блокуючи інтерфейс.

**Скріншоти:**
![Full Page Loading](./screenshots/Loading.png)
![Component Skeleton](./screenshots/SkeletonLoading.png)
![Streaming Code](./screenshots/StreamingComponent.png)

**Мої думки/питання:**
Стрімінг кардинально змінює UX. Замість білого екрану користувач одразу бачить структуру сайту. Дуже зручно, що можна керувати завантаженням кожного шматочка сторінки окремо через Suspense.